#lang racket

;; PURPOSE: To define and test procedures accept and chain.

;; Determenistic Finite Automaton begins here.

;; Accept function that takes in a list of 0's and 1's.

(define accept
  (lambda (lst)
    (cond
      ((null? lst) #t)
      (else (state "A" lst))
      )
    )
)

;; State function is stae machine that cycles through state A-C based on list input.

(define state
  (lambda (alpha lst)
    (cond
      ((eqv? alpha "A")
       (cond
         ((null? lst) #t)
         ((= 1 (car lst)) (state "B" (cdr lst)) )
         (else (state "A" (cdr lst)))
         )
       )
      ((eqv? alpha "B")
       (cond
         ((null? lst) #f)
         ((= 1 (car lst)) (state "C" (cdr lst)))
         (else (state "B" (cdr lst)))
         )
       )
      ((eqv? alpha "C")
       (cond
         ((null? lst) #f)
         ((= 1 (car lst)) (state "A" (cdr lst)))
         (else (state "C" (cdr lst)))
         )
       )
      )
    )
  )

;; Collatz problem begins here

;; Function that returns f(x)=3x+1 if input is odd and f(x)=x/2 if input is even.

(define f
  (lambda (x)
    (cond
      ((= (modulo x 2) 0) (/ x 2))
      (else (+ 1 (* 3 x)))
      )
    )
)

;; Chain function takes integer input and returns list of values generated by f(x) until base case x=1.
;; List is generated by prepending value of f(x) to list, then recursively call chain until base case. 

(define chain
  (lambda (x)
    (cond
      ((= x 1) '(1))
      (else (cons x (chain (f x))))
      )
    )
)
